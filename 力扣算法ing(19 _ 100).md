
# 3.6  238.除自身以外的乘积

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

 

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

 

**提示：**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- 输入 **保证** 数组 `answer[i]` 在  **32 位** 整数范围内



我的思路：

循环一次得到总乘积

循环第二次得到最后的结果，准备用总的除数组

！！！请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

行吧，我的思路错了

双指针？

不能直接修改数组的值！这可能导致不可预见的行为，尤其是如果调用者还打算使用原始数组的话。

时间超限！！人生好难啊！O(平方)

两个遍历不要嵌套循环

题解：

利用两个单独的循环来避免使用除输入数组以外的额外空间（例如，不使用另一个数组来存储乘积）。第一个循环计算左侧乘积，第二个循环计算右侧乘积，并将它们相乘。这样，每个元素只被访问两次，使得算法的时间复杂度为 O(n)，空间复杂度为 O(1)

代码：

```
function productExceptSelf(nums: number[]): number[] {
    let len = nums.length;
    let ans = [];

    // 计算左侧所有元素的乘积
    let left = 1;
    for (let i = 0; i < len; i++) {
        ans[i] = left; // 将左侧乘积存储在结果数组中
        left *= nums[i]; // 更新左侧乘积（乘以当前元素）
    }

    // 计算右侧所有元素的乘积，并与左侧乘积相乘
    let right = 1;
    for (let j = len - 1; j >= 0; j--) {
        ans[j] *= right; // 将右侧乘积与左侧乘积相乘，并更新结果数组
        right *= nums[j]; // 更新右侧乘积（乘以当前元素）
    }

    return ans;
}

```

h 是一个重要的步骤，以避免不必要的翻转。

```
function fanzhuan(nums:number[] , start:number , end:number):void{
    while(start < end){
        let temp = nums[start];
        nums[start] = nums[end];
        nums[end] = temp;
        start++;
        end--;
    }
}
function rotate(nums: number[], k: number): void {
    let len = nums.length;
     k = k % len; 
    fanzhuan(nums , 0 , len - 1 );
    fanzhuan(nums , 0 , k - 1);
    fanzhuan(nums , k , len - 1);
};
```

还是有进步的我觉得，起码案例过了，只是时间方面需要优化，来日可期！！！！

# 3.6  238.除自身以外的乘积

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

 

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

 

**提示：**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- 输入 **保证** 数组 `answer[i]` 在  **32 位** 整数范围内



我的思路：

循环一次得到总乘积

循环第二次得到最后的结果，准备用总的除数组

！！！请 不要使用除法，且在 O(n) 时间复杂度内完成此题。

行吧，我的思路错了

双指针？

不能直接修改数组的值！这可能导致不可预见的行为，尤其是如果调用者还打算使用原始数组的话。

时间超限！！人生好难啊！O(平方)

两个遍历不要嵌套循环

题解：

利用两个单独的循环来避免使用除输入数组以外的额外空间（例如，不使用另一个数组来存储乘积）。第一个循环计算左侧乘积，第二个循环计算右侧乘积，并将它们相乘。这样，每个元素只被访问两次，使得算法的时间复杂度为 O(n)，空间复杂度为 O(1)

代码：

```
function productExceptSelf(nums: number[]): number[] {
    let len = nums.length;
    let ans = [];

    // 计算左侧所有元素的乘积
    let left = 1;
    for (let i = 0; i < len; i++) {
        ans[i] = left; // 将左侧乘积存储在结果数组中
        left *= nums[i]; // 更新左侧乘积（乘以当前元素）
    }

    // 计算右侧所有元素的乘积，并与左侧乘积相乘
    let right = 1;
    for (let j = len - 1; j >= 0; j--) {
        ans[j] *= right; // 将右侧乘积与左侧乘积相乘，并更新结果数组
        right *= nums[j]; // 更新右侧乘积（乘以当前元素）
    }

    return ans;
}


```
我以为这道题还比较简单，没有想到啊，写了很久很久(心儿都碎了)，然后感觉也有点费脑子，只能说加油吧！

