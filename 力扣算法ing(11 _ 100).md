# 2.28 239滑动窗口的最大值

本来以为是一道很简单的题（虽然显示的是困难），写的第一次案例过了结果时间超时，后面看来一下大神的解析，那就总结一下吧~~~

我的思路：

我的思路：滑动窗口，而且是定长的滑动窗口

1,3,-1,-3,5,3,6,7

​            * *  *

arr[3,3,5,5,6,7]

将华东窗口存放在数组当中，每次去掉左值，前进右值Math.max([...numArr])

k = 3

arr[0] = nums[0] = 1

arr[1] = nums[1] = 3

arr[2] = nums[2] = -1

arr[1 , 3 , -1] 3

代码：

```
function maxSlidingWindow(nums: number[], k: number): number[] {
    let i = 0 ;                        
    let j = k ;
    let arr = [];
    let ans = [];
    let len = nums.length;
    for(let m = 0 ; m < j ; m++){
        arr[m] = nums[m]
    }
    // 开始滑窗
    while( j <= len){
        let max = Math.max(...arr)
        ans.push(max);
        arr.shift();
        arr.push(nums[j]);
        i++;
        j++;
    }
    return ans;
};
```

1. 时间超限，案例正确
2. 时间朝鲜的原因可能是：
3. 最大值计算：你使用 Math.max(...arr) 来计算数组中的最大值，这在每次滑动窗口时都需要遍历整个窗口，效率较低，但逻辑上是正确的。

题解：

**滑动窗口最大值**问题的核心思想是利用一个双端队列（deque）来存储窗口内元素的索引，而不是元素的值。这个队列将帮助我们维持窗口内元素的最大值，同时允许我们在O(1)的时间复杂度内完成以下操作：

1. **维持队列递减**：队列的尾部存储的是窗口内元素的索引，并且这些索引对应的值是递减的。这意味着队列的首部始终是当前窗口的最大值。
2. **移除不在窗口内的元素**：每当窗口移动时，我们需要检查队列的首部元素是否超出了窗口的左边界。如果是，我们需要从队列的首部移除它。
3. **记录最大值**：一旦窗口形成（即至少包含k个元素），我们就记录队列的首部元素作为当前窗口的最大值。

为什么要存储索引呢？

1. **判断元素是否在窗口内**：
2. - 由于窗口是动态移动的，我们需要一种方法来判断队列中的元素是否仍然在当前窗口内。通过保存索引，我们可以轻松地计算出元素是否超出了窗口的左边界（即索引小于当前索引减去窗口大小）。
3. **维持元素的顺序**：
4. - 队列需要维持窗口内元素的递减顺序，这样队列的首部始终是当前窗口的最大值。通过索引，我们可以直接访问数组 `nums` 中对应的值，而不需要移动大量元素来维持顺序。
5. **避免重复元素的问题**：
6. - 如果直接保存值，那么在存在重复元素的情况下，我们无法区分这些元素是否属于同一个窗口。保存索引可以确保每个元素都是唯一的，即使它们的值相同。
7. **高效地更新最大值**：
8. - 当窗口移动时，我们只需要检查队列的首部元素是否超出了窗口的左边界，并相应地移除它。这样可以高效地更新当前窗口的最大值，而不需要遍历整个窗口。
9. **支持动态数组**：
10. - 如果数组 `nums` 的值在动态变化，或者我们不知道数组的具体内容，保存索引允许我们灵活地处理任何类型的数值，而不仅仅是整数。

代码：

```
function maxSlidingWindow(nums: number[], k: number): number[] {
    let ans = [];      
    // 队列，存储索引
    let q = [];
    let len = nums.length;
    for (let i = 0; i < len; i++) { 
        // 维持队列递减
        while (q.length && nums[i] >= nums[q[q.length - 1]]) {
            q.pop();
        }
        q.push(i);
        // 移除不在窗口内的元素
        if (i - q[0] >= k) {
            q.shift();
        }
        // 窗口形成后，记录最大值
        if (i >= k - 1) {
            ans.push(nums[q[0]]);
        }
    }
    return ans;
};
```

我们需要检查队列的首部元素是否超出了窗口的左边界。如果是，我们需要从队列的首部移除它。
3. **记录最大值**：一旦窗口形成（即至少包含k个元素），我们就记录队列的首部元素作为当前窗口的最大值。

为什么要存储索引呢？

1. **判断元素是否在窗口内**：
2. - 由于窗口是动态移动的，我们需要一种方法来判断队列中的元素是否仍然在当前窗口内。通过保存索引，我们可以轻松地计算出元素是否超出了窗口的左边界（即索引小于当前索引减去窗口大小）。
3. **维持元素的顺序**：
4. - 队列需要维持窗口内元素的递减顺序，这样队列的首部始终是当前窗口的最大值。通过索引，我们可以直接访问数组 `nums` 中对应的值，而不需要移动大量元素来维持顺序。
5. **避免重复元素的问题**：
6. - 如果直接保存值，那么在存在重复元素的情况下，我们无法区分这些元素是否属于同一个窗口。保存索引可以确保每个元素都是唯一的，即使它们的值相同。
7. **高效地更新最大值**：
8. - 当窗口移动时，我们只需要检查队列的首部元素是否超出了窗口的左边界，并相应地移除它。这样可以高效地更新当前窗口的最大值，而不需要遍历整个窗口。
9. **支持动态数组**：
10. - 如果数组 `nums` 的值在动态变化，或者我们不知道数组的具体内容，保存索引允许我们灵活地处理任何类型的数值，而不仅仅是整数。

代码：

```
function maxSlidingWindow(nums: number[], k: number): number[] {
    let ans = [];      
    // 队列，存储索引
    let q = [];
    let len = nums.length;
    for (let i = 0; i < len; i++) { 
        // 维持队列递减
        while (q.length && nums[i] >= nums[q[q.length - 1]]) {
            q.pop();
        }
        q.push(i);
        // 移除不在窗口内的元素
        if (i - q[0] >= k) {
            q.shift();
        }
        // 窗口形成后，记录最大值
        if (i >= k - 1) {
            ans.push(nums[q[0]]);
        }
    }
    return ans;
};
```

